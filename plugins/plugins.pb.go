// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: plugins.proto

package plugins

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GetPluginMetadataRequest struct {
}

func (m *GetPluginMetadataRequest) Reset()         { *m = GetPluginMetadataRequest{} }
func (m *GetPluginMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*GetPluginMetadataRequest) ProtoMessage()    {}
func (*GetPluginMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{0}
}
func (m *GetPluginMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPluginMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPluginMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPluginMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPluginMetadataRequest.Merge(m, src)
}
func (m *GetPluginMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPluginMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPluginMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPluginMetadataRequest proto.InternalMessageInfo

type GetPluginMetadataResponse struct {
	SupportedFunctions       []string `protobuf:"bytes,1,rep,name=supported_functions,json=supportedFunctions,proto3" json:"supported_functions,omitempty"`
	SupportedExpressionTypes []int64  `protobuf:"varint,2,rep,packed,name=supported_expression_types,json=supportedExpressionTypes,proto3" json:"supported_expression_types,omitempty"`
}

func (m *GetPluginMetadataResponse) Reset()         { *m = GetPluginMetadataResponse{} }
func (m *GetPluginMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*GetPluginMetadataResponse) ProtoMessage()    {}
func (*GetPluginMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{1}
}
func (m *GetPluginMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPluginMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPluginMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPluginMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPluginMetadataResponse.Merge(m, src)
}
func (m *GetPluginMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPluginMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPluginMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPluginMetadataResponse proto.InternalMessageInfo

func (m *GetPluginMetadataResponse) GetSupportedFunctions() []string {
	if m != nil {
		return m.SupportedFunctions
	}
	return nil
}

func (m *GetPluginMetadataResponse) GetSupportedExpressionTypes() []int64 {
	if m != nil {
		return m.SupportedExpressionTypes
	}
	return nil
}

type GetSchemaRequest struct {
	Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
}

func (m *GetSchemaRequest) Reset()         { *m = GetSchemaRequest{} }
func (m *GetSchemaRequest) String() string { return proto.CompactTextString(m) }
func (*GetSchemaRequest) ProtoMessage()    {}
func (*GetSchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{2}
}
func (m *GetSchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSchemaRequest.Merge(m, src)
}
func (m *GetSchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSchemaRequest proto.InternalMessageInfo

func (m *GetSchemaRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

type Schema struct {
	Fields []*SchemaField `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// time_field is -1 if not present.
	TimeField int64 `protobuf:"varint,2,opt,name=time_field,json=timeField,proto3" json:"time_field,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{3}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetFields() []*SchemaField {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Schema) GetTimeField() int64 {
	if m != nil {
		return m.TimeField
	}
	return 0
}

type SchemaField struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type *Type  `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *SchemaField) Reset()         { *m = SchemaField{} }
func (m *SchemaField) String() string { return proto.CompactTextString(m) }
func (*SchemaField) ProtoMessage()    {}
func (*SchemaField) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{4}
}
func (m *SchemaField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaField.Merge(m, src)
}
func (m *SchemaField) XXX_Size() int {
	return m.Size()
}
func (m *SchemaField) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaField.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaField proto.InternalMessageInfo

func (m *SchemaField) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaField) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

type RunRequest struct {
	Table          string            `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	Predicate      *Expression       `protobuf:"bytes,2,opt,name=predicate,proto3" json:"predicate,omitempty"`
	VariableValues map[string]*Value `protobuf:"bytes,3,rep,name=variable_values,json=variableValues,proto3" json:"variable_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RunRequest) Reset()         { *m = RunRequest{} }
func (m *RunRequest) String() string { return proto.CompactTextString(m) }
func (*RunRequest) ProtoMessage()    {}
func (*RunRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{5}
}
func (m *RunRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunRequest.Merge(m, src)
}
func (m *RunRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunRequest proto.InternalMessageInfo

func (m *RunRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *RunRequest) GetPredicate() *Expression {
	if m != nil {
		return m.Predicate
	}
	return nil
}

func (m *RunRequest) GetVariableValues() map[string]*Value {
	if m != nil {
		return m.VariableValues
	}
	return nil
}

type Expression struct {
	Type *Type `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Types that are valid to be assigned to Expression:
	//	*Expression_Variable
	//	*Expression_Constant
	//	*Expression_FunctionCall
	//	*Expression_And
	//	*Expression_Or
	//	*Expression_TypeAssertion
	Expression isExpression_Expression `protobuf_oneof:"expression"`
}

func (m *Expression) Reset()         { *m = Expression{} }
func (m *Expression) String() string { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()    {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{6}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(m, src)
}
func (m *Expression) XXX_Size() int {
	return m.Size()
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

type isExpression_Expression interface {
	isExpression_Expression()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Expression_Variable struct {
	Variable *Variable `protobuf:"bytes,2,opt,name=variable,proto3,oneof"`
}
type Expression_Constant struct {
	Constant *Constant `protobuf:"bytes,3,opt,name=constant,proto3,oneof"`
}
type Expression_FunctionCall struct {
	FunctionCall *FunctionCall `protobuf:"bytes,4,opt,name=function_call,json=functionCall,proto3,oneof"`
}
type Expression_And struct {
	And *And `protobuf:"bytes,5,opt,name=and,proto3,oneof"`
}
type Expression_Or struct {
	Or *Or `protobuf:"bytes,6,opt,name=or,proto3,oneof"`
}
type Expression_TypeAssertion struct {
	TypeAssertion *TypeAssertion `protobuf:"bytes,7,opt,name=type_assertion,json=typeAssertion,proto3,oneof"`
}

func (*Expression_Variable) isExpression_Expression()      {}
func (*Expression_Constant) isExpression_Expression()      {}
func (*Expression_FunctionCall) isExpression_Expression()  {}
func (*Expression_And) isExpression_Expression()           {}
func (*Expression_Or) isExpression_Expression()            {}
func (*Expression_TypeAssertion) isExpression_Expression() {}

func (m *Expression) GetExpression() isExpression_Expression {
	if m != nil {
		return m.Expression
	}
	return nil
}

func (m *Expression) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Expression) GetVariable() *Variable {
	if x, ok := m.GetExpression().(*Expression_Variable); ok {
		return x.Variable
	}
	return nil
}

func (m *Expression) GetConstant() *Constant {
	if x, ok := m.GetExpression().(*Expression_Constant); ok {
		return x.Constant
	}
	return nil
}

func (m *Expression) GetFunctionCall() *FunctionCall {
	if x, ok := m.GetExpression().(*Expression_FunctionCall); ok {
		return x.FunctionCall
	}
	return nil
}

func (m *Expression) GetAnd() *And {
	if x, ok := m.GetExpression().(*Expression_And); ok {
		return x.And
	}
	return nil
}

func (m *Expression) GetOr() *Or {
	if x, ok := m.GetExpression().(*Expression_Or); ok {
		return x.Or
	}
	return nil
}

func (m *Expression) GetTypeAssertion() *TypeAssertion {
	if x, ok := m.GetExpression().(*Expression_TypeAssertion); ok {
		return x.TypeAssertion
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expression_OneofMarshaler, _Expression_OneofUnmarshaler, _Expression_OneofSizer, []interface{}{
		(*Expression_Variable)(nil),
		(*Expression_Constant)(nil),
		(*Expression_FunctionCall)(nil),
		(*Expression_And)(nil),
		(*Expression_Or)(nil),
		(*Expression_TypeAssertion)(nil),
	}
}

func _Expression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expression)
	// expression
	switch x := m.Expression.(type) {
	case *Expression_Variable:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Variable); err != nil {
			return err
		}
	case *Expression_Constant:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Constant); err != nil {
			return err
		}
	case *Expression_FunctionCall:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FunctionCall); err != nil {
			return err
		}
	case *Expression_And:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.And); err != nil {
			return err
		}
	case *Expression_Or:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Or); err != nil {
			return err
		}
	case *Expression_TypeAssertion:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TypeAssertion); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Expression.Expression has unexpected type %T", x)
	}
	return nil
}

func _Expression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expression)
	switch tag {
	case 2: // expression.variable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Variable)
		err := b.DecodeMessage(msg)
		m.Expression = &Expression_Variable{msg}
		return true, err
	case 3: // expression.constant
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Constant)
		err := b.DecodeMessage(msg)
		m.Expression = &Expression_Constant{msg}
		return true, err
	case 4: // expression.function_call
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FunctionCall)
		err := b.DecodeMessage(msg)
		m.Expression = &Expression_FunctionCall{msg}
		return true, err
	case 5: // expression.and
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(And)
		err := b.DecodeMessage(msg)
		m.Expression = &Expression_And{msg}
		return true, err
	case 6: // expression.or
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Or)
		err := b.DecodeMessage(msg)
		m.Expression = &Expression_Or{msg}
		return true, err
	case 7: // expression.type_assertion
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeAssertion)
		err := b.DecodeMessage(msg)
		m.Expression = &Expression_TypeAssertion{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Expression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expression)
	// expression
	switch x := m.Expression.(type) {
	case *Expression_Variable:
		s := proto.Size(x.Variable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Constant:
		s := proto.Size(x.Constant)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_FunctionCall:
		s := proto.Size(x.FunctionCall)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_And:
		s := proto.Size(x.And)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Or:
		s := proto.Size(x.Or)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_TypeAssertion:
		s := proto.Size(x.TypeAssertion)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Variable struct {
	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IsLevel_0 bool   `protobuf:"varint,2,opt,name=is_level_0,json=isLevel0,proto3" json:"is_level_0,omitempty"`
}

func (m *Variable) Reset()         { *m = Variable{} }
func (m *Variable) String() string { return proto.CompactTextString(m) }
func (*Variable) ProtoMessage()    {}
func (*Variable) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{7}
}
func (m *Variable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Variable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Variable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Variable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Variable.Merge(m, src)
}
func (m *Variable) XXX_Size() int {
	return m.Size()
}
func (m *Variable) XXX_DiscardUnknown() {
	xxx_messageInfo_Variable.DiscardUnknown(m)
}

var xxx_messageInfo_Variable proto.InternalMessageInfo

func (m *Variable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Variable) GetIsLevel_0() bool {
	if m != nil {
		return m.IsLevel_0
	}
	return false
}

type Constant struct {
	Value *Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Constant) Reset()         { *m = Constant{} }
func (m *Constant) String() string { return proto.CompactTextString(m) }
func (*Constant) ProtoMessage()    {}
func (*Constant) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{8}
}
func (m *Constant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Constant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Constant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Constant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Constant.Merge(m, src)
}
func (m *Constant) XXX_Size() int {
	return m.Size()
}
func (m *Constant) XXX_DiscardUnknown() {
	xxx_messageInfo_Constant.DiscardUnknown(m)
}

var xxx_messageInfo_Constant proto.InternalMessageInfo

func (m *Constant) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type FunctionCall struct {
	Name      string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Arguments []*Expression `protobuf:"bytes,2,rep,name=arguments,proto3" json:"arguments,omitempty"`
}

func (m *FunctionCall) Reset()         { *m = FunctionCall{} }
func (m *FunctionCall) String() string { return proto.CompactTextString(m) }
func (*FunctionCall) ProtoMessage()    {}
func (*FunctionCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{9}
}
func (m *FunctionCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FunctionCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FunctionCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionCall.Merge(m, src)
}
func (m *FunctionCall) XXX_Size() int {
	return m.Size()
}
func (m *FunctionCall) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionCall.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionCall proto.InternalMessageInfo

func (m *FunctionCall) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FunctionCall) GetArguments() []*Expression {
	if m != nil {
		return m.Arguments
	}
	return nil
}

type And struct {
	Arguments []*Expression `protobuf:"bytes,1,rep,name=arguments,proto3" json:"arguments,omitempty"`
}

func (m *And) Reset()         { *m = And{} }
func (m *And) String() string { return proto.CompactTextString(m) }
func (*And) ProtoMessage()    {}
func (*And) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{10}
}
func (m *And) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *And) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_And.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *And) XXX_Merge(src proto.Message) {
	xxx_messageInfo_And.Merge(m, src)
}
func (m *And) XXX_Size() int {
	return m.Size()
}
func (m *And) XXX_DiscardUnknown() {
	xxx_messageInfo_And.DiscardUnknown(m)
}

var xxx_messageInfo_And proto.InternalMessageInfo

func (m *And) GetArguments() []*Expression {
	if m != nil {
		return m.Arguments
	}
	return nil
}

type Or struct {
	Arguments []*Expression `protobuf:"bytes,2,rep,name=arguments,proto3" json:"arguments,omitempty"`
}

func (m *Or) Reset()         { *m = Or{} }
func (m *Or) String() string { return proto.CompactTextString(m) }
func (*Or) ProtoMessage()    {}
func (*Or) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{11}
}
func (m *Or) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Or) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Or.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Or) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Or.Merge(m, src)
}
func (m *Or) XXX_Size() int {
	return m.Size()
}
func (m *Or) XXX_DiscardUnknown() {
	xxx_messageInfo_Or.DiscardUnknown(m)
}

var xxx_messageInfo_Or proto.InternalMessageInfo

func (m *Or) GetArguments() []*Expression {
	if m != nil {
		return m.Arguments
	}
	return nil
}

type TypeAssertion struct {
	Expression *Expression `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	TargetType *Type       `protobuf:"bytes,2,opt,name=target_type,json=targetType,proto3" json:"target_type,omitempty"`
}

func (m *TypeAssertion) Reset()         { *m = TypeAssertion{} }
func (m *TypeAssertion) String() string { return proto.CompactTextString(m) }
func (*TypeAssertion) ProtoMessage()    {}
func (*TypeAssertion) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{12}
}
func (m *TypeAssertion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeAssertion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeAssertion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeAssertion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeAssertion.Merge(m, src)
}
func (m *TypeAssertion) XXX_Size() int {
	return m.Size()
}
func (m *TypeAssertion) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeAssertion.DiscardUnknown(m)
}

var xxx_messageInfo_TypeAssertion proto.InternalMessageInfo

func (m *TypeAssertion) GetExpression() *Expression {
	if m != nil {
		return m.Expression
	}
	return nil
}

func (m *TypeAssertion) GetTargetType() *Type {
	if m != nil {
		return m.TargetType
	}
	return nil
}

type Value struct {
	Type *Type `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Value_Null
	//	*Value_Int
	//	*Value_Float
	//	*Value_Boolean
	//	*Value_Str
	//	*Value_Time
	//	*Value_Duration
	//	*Value_List
	//	*Value_FieldValues
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{13}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Value interface {
	isValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_Null struct {
	Null bool `protobuf:"varint,2,opt,name=null,proto3,oneof"`
}
type Value_Int struct {
	Int int64 `protobuf:"varint,3,opt,name=int,proto3,oneof"`
}
type Value_Float struct {
	Float float64 `protobuf:"fixed64,4,opt,name=float,proto3,oneof"`
}
type Value_Boolean struct {
	Boolean bool `protobuf:"varint,5,opt,name=boolean,proto3,oneof"`
}
type Value_Str struct {
	Str string `protobuf:"bytes,6,opt,name=str,proto3,oneof"`
}
type Value_Time struct {
	Time *types.Timestamp `protobuf:"bytes,7,opt,name=time,proto3,oneof"`
}
type Value_Duration struct {
	Duration *types.Duration `protobuf:"bytes,8,opt,name=duration,proto3,oneof"`
}
type Value_List struct {
	List *Values `protobuf:"bytes,9,opt,name=list,proto3,oneof"`
}
type Value_FieldValues struct {
	FieldValues *Values `protobuf:"bytes,10,opt,name=field_values,json=fieldValues,proto3,oneof"`
}

func (*Value_Null) isValue_Value()        {}
func (*Value_Int) isValue_Value()         {}
func (*Value_Float) isValue_Value()       {}
func (*Value_Boolean) isValue_Value()     {}
func (*Value_Str) isValue_Value()         {}
func (*Value_Time) isValue_Value()        {}
func (*Value_Duration) isValue_Value()    {}
func (*Value_List) isValue_Value()        {}
func (*Value_FieldValues) isValue_Value() {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Value) GetNull() bool {
	if x, ok := m.GetValue().(*Value_Null); ok {
		return x.Null
	}
	return false
}

func (m *Value) GetInt() int64 {
	if x, ok := m.GetValue().(*Value_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Value) GetFloat() float64 {
	if x, ok := m.GetValue().(*Value_Float); ok {
		return x.Float
	}
	return 0
}

func (m *Value) GetBoolean() bool {
	if x, ok := m.GetValue().(*Value_Boolean); ok {
		return x.Boolean
	}
	return false
}

func (m *Value) GetStr() string {
	if x, ok := m.GetValue().(*Value_Str); ok {
		return x.Str
	}
	return ""
}

func (m *Value) GetTime() *types.Timestamp {
	if x, ok := m.GetValue().(*Value_Time); ok {
		return x.Time
	}
	return nil
}

func (m *Value) GetDuration() *types.Duration {
	if x, ok := m.GetValue().(*Value_Duration); ok {
		return x.Duration
	}
	return nil
}

func (m *Value) GetList() *Values {
	if x, ok := m.GetValue().(*Value_List); ok {
		return x.List
	}
	return nil
}

func (m *Value) GetFieldValues() *Values {
	if x, ok := m.GetValue().(*Value_FieldValues); ok {
		return x.FieldValues
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_Null)(nil),
		(*Value_Int)(nil),
		(*Value_Float)(nil),
		(*Value_Boolean)(nil),
		(*Value_Str)(nil),
		(*Value_Time)(nil),
		(*Value_Duration)(nil),
		(*Value_List)(nil),
		(*Value_FieldValues)(nil),
	}
}

func _Value_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_Null:
		t := uint64(0)
		if x.Null {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Value_Int:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int))
	case *Value_Float:
		_ = b.EncodeVarint(4<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Float))
	case *Value_Boolean:
		t := uint64(0)
		if x.Boolean {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Value_Str:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Str)
	case *Value_Time:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Time); err != nil {
			return err
		}
	case *Value_Duration:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Duration); err != nil {
			return err
		}
	case *Value_List:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *Value_FieldValues:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FieldValues); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Value.Value has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 2: // value.null
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Null{x != 0}
		return true, err
	case 3: // value.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Int{int64(x)}
		return true, err
	case 4: // value.float
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Value_Float{math.Float64frombits(x)}
		return true, err
	case 5: // value.boolean
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Boolean{x != 0}
		return true, err
	case 6: // value.str
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Value_Str{x}
		return true, err
	case 7: // value.time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(types.Timestamp)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Time{msg}
		return true, err
	case 8: // value.duration
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(types.Duration)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Duration{msg}
		return true, err
	case 9: // value.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Values)
		err := b.DecodeMessage(msg)
		m.Value = &Value_List{msg}
		return true, err
	case 10: // value.field_values
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Values)
		err := b.DecodeMessage(msg)
		m.Value = &Value_FieldValues{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_Null:
		n += 1 // tag and wire
		n += 1
	case *Value_Int:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Int))
	case *Value_Float:
		n += 1 // tag and wire
		n += 8
	case *Value_Boolean:
		n += 1 // tag and wire
		n += 1
	case *Value_Str:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Str)))
		n += len(x.Str)
	case *Value_Time:
		s := proto.Size(x.Time)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_Duration:
		s := proto.Size(x.Duration)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_List:
		s := proto.Size(x.List)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_FieldValues:
		s := proto.Size(x.FieldValues)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Values struct {
	Values []*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *Values) Reset()         { *m = Values{} }
func (m *Values) String() string { return proto.CompactTextString(m) }
func (*Values) ProtoMessage()    {}
func (*Values) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{14}
}
func (m *Values) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Values) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Values.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Values) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Values.Merge(m, src)
}
func (m *Values) XXX_Size() int {
	return m.Size()
}
func (m *Values) XXX_DiscardUnknown() {
	xxx_messageInfo_Values.DiscardUnknown(m)
}

var xxx_messageInfo_Values proto.InternalMessageInfo

func (m *Values) GetValues() []*Value {
	if m != nil {
		return m.Values
	}
	return nil
}

type RunMessage struct {
	// Types that are valid to be assigned to Content:
	//	*RunMessage_MetadataMessage
	//	*RunMessage_Record
	Content isRunMessage_Content `protobuf_oneof:"content"`
}

func (m *RunMessage) Reset()         { *m = RunMessage{} }
func (m *RunMessage) String() string { return proto.CompactTextString(m) }
func (*RunMessage) ProtoMessage()    {}
func (*RunMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{15}
}
func (m *RunMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunMessage.Merge(m, src)
}
func (m *RunMessage) XXX_Size() int {
	return m.Size()
}
func (m *RunMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RunMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RunMessage proto.InternalMessageInfo

type isRunMessage_Content interface {
	isRunMessage_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RunMessage_MetadataMessage struct {
	MetadataMessage *MetadataMessage `protobuf:"bytes,1,opt,name=metadata_message,json=metadataMessage,proto3,oneof"`
}
type RunMessage_Record struct {
	Record *Record `protobuf:"bytes,2,opt,name=record,proto3,oneof"`
}

func (*RunMessage_MetadataMessage) isRunMessage_Content() {}
func (*RunMessage_Record) isRunMessage_Content()          {}

func (m *RunMessage) GetContent() isRunMessage_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *RunMessage) GetMetadataMessage() *MetadataMessage {
	if x, ok := m.GetContent().(*RunMessage_MetadataMessage); ok {
		return x.MetadataMessage
	}
	return nil
}

func (m *RunMessage) GetRecord() *Record {
	if x, ok := m.GetContent().(*RunMessage_Record); ok {
		return x.Record
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RunMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RunMessage_OneofMarshaler, _RunMessage_OneofUnmarshaler, _RunMessage_OneofSizer, []interface{}{
		(*RunMessage_MetadataMessage)(nil),
		(*RunMessage_Record)(nil),
	}
}

func _RunMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RunMessage)
	// content
	switch x := m.Content.(type) {
	case *RunMessage_MetadataMessage:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MetadataMessage); err != nil {
			return err
		}
	case *RunMessage_Record:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Record); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RunMessage.Content has unexpected type %T", x)
	}
	return nil
}

func _RunMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RunMessage)
	switch tag {
	case 1: // content.metadata_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MetadataMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RunMessage_MetadataMessage{msg}
		return true, err
	case 2: // content.record
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Record)
		err := b.DecodeMessage(msg)
		m.Content = &RunMessage_Record{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RunMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RunMessage)
	// content
	switch x := m.Content.(type) {
	case *RunMessage_MetadataMessage:
		s := proto.Size(x.MetadataMessage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RunMessage_Record:
		s := proto.Size(x.Record)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MetadataMessage struct {
	// Types that are valid to be assigned to MetadataMessage:
	//	*MetadataMessage_Watermark
	MetadataMessage isMetadataMessage_MetadataMessage `protobuf_oneof:"metadata_message"`
}

func (m *MetadataMessage) Reset()         { *m = MetadataMessage{} }
func (m *MetadataMessage) String() string { return proto.CompactTextString(m) }
func (*MetadataMessage) ProtoMessage()    {}
func (*MetadataMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{16}
}
func (m *MetadataMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataMessage.Merge(m, src)
}
func (m *MetadataMessage) XXX_Size() int {
	return m.Size()
}
func (m *MetadataMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataMessage proto.InternalMessageInfo

type isMetadataMessage_MetadataMessage interface {
	isMetadataMessage_MetadataMessage()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MetadataMessage_Watermark struct {
	Watermark *types.Timestamp `protobuf:"bytes,1,opt,name=watermark,proto3,oneof"`
}

func (*MetadataMessage_Watermark) isMetadataMessage_MetadataMessage() {}

func (m *MetadataMessage) GetMetadataMessage() isMetadataMessage_MetadataMessage {
	if m != nil {
		return m.MetadataMessage
	}
	return nil
}

func (m *MetadataMessage) GetWatermark() *types.Timestamp {
	if x, ok := m.GetMetadataMessage().(*MetadataMessage_Watermark); ok {
		return x.Watermark
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MetadataMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MetadataMessage_OneofMarshaler, _MetadataMessage_OneofUnmarshaler, _MetadataMessage_OneofSizer, []interface{}{
		(*MetadataMessage_Watermark)(nil),
	}
}

func _MetadataMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MetadataMessage)
	// metadata_message
	switch x := m.MetadataMessage.(type) {
	case *MetadataMessage_Watermark:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Watermark); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MetadataMessage.MetadataMessage has unexpected type %T", x)
	}
	return nil
}

func _MetadataMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MetadataMessage)
	switch tag {
	case 1: // metadata_message.watermark
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(types.Timestamp)
		err := b.DecodeMessage(msg)
		m.MetadataMessage = &MetadataMessage_Watermark{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MetadataMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MetadataMessage)
	// metadata_message
	switch x := m.MetadataMessage.(type) {
	case *MetadataMessage_Watermark:
		s := proto.Size(x.Watermark)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Record struct {
	Value      *Values `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Retraction bool    `protobuf:"varint,2,opt,name=retraction,proto3" json:"retraction,omitempty"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{17}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetValue() *Values {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Record) GetRetraction() bool {
	if m != nil {
		return m.Retraction
	}
	return false
}

type Type struct {
	// Types that are valid to be assigned to Type:
	//	*Type_Null
	//	*Type_Int
	//	*Type_Float
	//	*Type_Boolean
	//	*Type_Str
	//	*Type_Time
	//	*Type_Duration
	//	*Type_List
	//	*Type_Struct
	//	*Type_Union
	//	*Type_Any
	Type isType_Type `protobuf_oneof:"type"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{18}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.Size()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

type isType_Type interface {
	isType_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Type_Null struct {
	Null *TypeNull `protobuf:"bytes,1,opt,name=null,proto3,oneof"`
}
type Type_Int struct {
	Int *TypeInt `protobuf:"bytes,2,opt,name=int,proto3,oneof"`
}
type Type_Float struct {
	Float *TypeFloat `protobuf:"bytes,3,opt,name=float,proto3,oneof"`
}
type Type_Boolean struct {
	Boolean *TypeBoolean `protobuf:"bytes,4,opt,name=boolean,proto3,oneof"`
}
type Type_Str struct {
	Str *TypeStr `protobuf:"bytes,5,opt,name=str,proto3,oneof"`
}
type Type_Time struct {
	Time *TypeTime `protobuf:"bytes,6,opt,name=time,proto3,oneof"`
}
type Type_Duration struct {
	Duration *TypeDuration `protobuf:"bytes,7,opt,name=duration,proto3,oneof"`
}
type Type_List struct {
	List *TypeList `protobuf:"bytes,8,opt,name=list,proto3,oneof"`
}
type Type_Struct struct {
	Struct *TypeStruct `protobuf:"bytes,9,opt,name=struct,proto3,oneof"`
}
type Type_Union struct {
	Union *TypeUnion `protobuf:"bytes,10,opt,name=union,proto3,oneof"`
}
type Type_Any struct {
	Any *TypeAny `protobuf:"bytes,11,opt,name=any,proto3,oneof"`
}

func (*Type_Null) isType_Type()     {}
func (*Type_Int) isType_Type()      {}
func (*Type_Float) isType_Type()    {}
func (*Type_Boolean) isType_Type()  {}
func (*Type_Str) isType_Type()      {}
func (*Type_Time) isType_Type()     {}
func (*Type_Duration) isType_Type() {}
func (*Type_List) isType_Type()     {}
func (*Type_Struct) isType_Type()   {}
func (*Type_Union) isType_Type()    {}
func (*Type_Any) isType_Type()      {}

func (m *Type) GetType() isType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Type) GetNull() *TypeNull {
	if x, ok := m.GetType().(*Type_Null); ok {
		return x.Null
	}
	return nil
}

func (m *Type) GetInt() *TypeInt {
	if x, ok := m.GetType().(*Type_Int); ok {
		return x.Int
	}
	return nil
}

func (m *Type) GetFloat() *TypeFloat {
	if x, ok := m.GetType().(*Type_Float); ok {
		return x.Float
	}
	return nil
}

func (m *Type) GetBoolean() *TypeBoolean {
	if x, ok := m.GetType().(*Type_Boolean); ok {
		return x.Boolean
	}
	return nil
}

func (m *Type) GetStr() *TypeStr {
	if x, ok := m.GetType().(*Type_Str); ok {
		return x.Str
	}
	return nil
}

func (m *Type) GetTime() *TypeTime {
	if x, ok := m.GetType().(*Type_Time); ok {
		return x.Time
	}
	return nil
}

func (m *Type) GetDuration() *TypeDuration {
	if x, ok := m.GetType().(*Type_Duration); ok {
		return x.Duration
	}
	return nil
}

func (m *Type) GetList() *TypeList {
	if x, ok := m.GetType().(*Type_List); ok {
		return x.List
	}
	return nil
}

func (m *Type) GetStruct() *TypeStruct {
	if x, ok := m.GetType().(*Type_Struct); ok {
		return x.Struct
	}
	return nil
}

func (m *Type) GetUnion() *TypeUnion {
	if x, ok := m.GetType().(*Type_Union); ok {
		return x.Union
	}
	return nil
}

func (m *Type) GetAny() *TypeAny {
	if x, ok := m.GetType().(*Type_Any); ok {
		return x.Any
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Type) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Type_OneofMarshaler, _Type_OneofUnmarshaler, _Type_OneofSizer, []interface{}{
		(*Type_Null)(nil),
		(*Type_Int)(nil),
		(*Type_Float)(nil),
		(*Type_Boolean)(nil),
		(*Type_Str)(nil),
		(*Type_Time)(nil),
		(*Type_Duration)(nil),
		(*Type_List)(nil),
		(*Type_Struct)(nil),
		(*Type_Union)(nil),
		(*Type_Any)(nil),
	}
}

func _Type_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Type)
	// type
	switch x := m.Type.(type) {
	case *Type_Null:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Null); err != nil {
			return err
		}
	case *Type_Int:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int); err != nil {
			return err
		}
	case *Type_Float:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Float); err != nil {
			return err
		}
	case *Type_Boolean:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Boolean); err != nil {
			return err
		}
	case *Type_Str:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Str); err != nil {
			return err
		}
	case *Type_Time:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Time); err != nil {
			return err
		}
	case *Type_Duration:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Duration); err != nil {
			return err
		}
	case *Type_List:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *Type_Struct:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Struct); err != nil {
			return err
		}
	case *Type_Union:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Union); err != nil {
			return err
		}
	case *Type_Any:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Type.Type has unexpected type %T", x)
	}
	return nil
}

func _Type_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Type)
	switch tag {
	case 1: // type.null
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeNull)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Null{msg}
		return true, err
	case 2: // type.int
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeInt)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Int{msg}
		return true, err
	case 3: // type.float
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeFloat)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Float{msg}
		return true, err
	case 4: // type.boolean
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeBoolean)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Boolean{msg}
		return true, err
	case 5: // type.str
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeStr)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Str{msg}
		return true, err
	case 6: // type.time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeTime)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Time{msg}
		return true, err
	case 7: // type.duration
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeDuration)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Duration{msg}
		return true, err
	case 8: // type.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeList)
		err := b.DecodeMessage(msg)
		m.Type = &Type_List{msg}
		return true, err
	case 9: // type.struct
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeStruct)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Struct{msg}
		return true, err
	case 10: // type.union
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeUnion)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Union{msg}
		return true, err
	case 11: // type.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeAny)
		err := b.DecodeMessage(msg)
		m.Type = &Type_Any{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Type_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Type)
	// type
	switch x := m.Type.(type) {
	case *Type_Null:
		s := proto.Size(x.Null)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Int:
		s := proto.Size(x.Int)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Float:
		s := proto.Size(x.Float)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Boolean:
		s := proto.Size(x.Boolean)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Str:
		s := proto.Size(x.Str)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Time:
		s := proto.Size(x.Time)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Duration:
		s := proto.Size(x.Duration)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_List:
		s := proto.Size(x.List)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Struct:
		s := proto.Size(x.Struct)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Union:
		s := proto.Size(x.Union)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Type_Any:
		s := proto.Size(x.Any)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TypeNull struct {
}

func (m *TypeNull) Reset()         { *m = TypeNull{} }
func (m *TypeNull) String() string { return proto.CompactTextString(m) }
func (*TypeNull) ProtoMessage()    {}
func (*TypeNull) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{19}
}
func (m *TypeNull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeNull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeNull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeNull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeNull.Merge(m, src)
}
func (m *TypeNull) XXX_Size() int {
	return m.Size()
}
func (m *TypeNull) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeNull.DiscardUnknown(m)
}

var xxx_messageInfo_TypeNull proto.InternalMessageInfo

type TypeInt struct {
}

func (m *TypeInt) Reset()         { *m = TypeInt{} }
func (m *TypeInt) String() string { return proto.CompactTextString(m) }
func (*TypeInt) ProtoMessage()    {}
func (*TypeInt) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{20}
}
func (m *TypeInt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeInt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeInt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeInt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeInt.Merge(m, src)
}
func (m *TypeInt) XXX_Size() int {
	return m.Size()
}
func (m *TypeInt) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeInt.DiscardUnknown(m)
}

var xxx_messageInfo_TypeInt proto.InternalMessageInfo

type TypeFloat struct {
}

func (m *TypeFloat) Reset()         { *m = TypeFloat{} }
func (m *TypeFloat) String() string { return proto.CompactTextString(m) }
func (*TypeFloat) ProtoMessage()    {}
func (*TypeFloat) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{21}
}
func (m *TypeFloat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeFloat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeFloat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeFloat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeFloat.Merge(m, src)
}
func (m *TypeFloat) XXX_Size() int {
	return m.Size()
}
func (m *TypeFloat) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeFloat.DiscardUnknown(m)
}

var xxx_messageInfo_TypeFloat proto.InternalMessageInfo

type TypeBoolean struct {
}

func (m *TypeBoolean) Reset()         { *m = TypeBoolean{} }
func (m *TypeBoolean) String() string { return proto.CompactTextString(m) }
func (*TypeBoolean) ProtoMessage()    {}
func (*TypeBoolean) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{22}
}
func (m *TypeBoolean) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeBoolean) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeBoolean.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeBoolean) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeBoolean.Merge(m, src)
}
func (m *TypeBoolean) XXX_Size() int {
	return m.Size()
}
func (m *TypeBoolean) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeBoolean.DiscardUnknown(m)
}

var xxx_messageInfo_TypeBoolean proto.InternalMessageInfo

type TypeStr struct {
}

func (m *TypeStr) Reset()         { *m = TypeStr{} }
func (m *TypeStr) String() string { return proto.CompactTextString(m) }
func (*TypeStr) ProtoMessage()    {}
func (*TypeStr) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{23}
}
func (m *TypeStr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeStr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeStr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeStr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeStr.Merge(m, src)
}
func (m *TypeStr) XXX_Size() int {
	return m.Size()
}
func (m *TypeStr) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeStr.DiscardUnknown(m)
}

var xxx_messageInfo_TypeStr proto.InternalMessageInfo

type TypeTime struct {
}

func (m *TypeTime) Reset()         { *m = TypeTime{} }
func (m *TypeTime) String() string { return proto.CompactTextString(m) }
func (*TypeTime) ProtoMessage()    {}
func (*TypeTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{24}
}
func (m *TypeTime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeTime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeTime.Merge(m, src)
}
func (m *TypeTime) XXX_Size() int {
	return m.Size()
}
func (m *TypeTime) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeTime.DiscardUnknown(m)
}

var xxx_messageInfo_TypeTime proto.InternalMessageInfo

type TypeDuration struct {
}

func (m *TypeDuration) Reset()         { *m = TypeDuration{} }
func (m *TypeDuration) String() string { return proto.CompactTextString(m) }
func (*TypeDuration) ProtoMessage()    {}
func (*TypeDuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{25}
}
func (m *TypeDuration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeDuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeDuration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeDuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeDuration.Merge(m, src)
}
func (m *TypeDuration) XXX_Size() int {
	return m.Size()
}
func (m *TypeDuration) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeDuration.DiscardUnknown(m)
}

var xxx_messageInfo_TypeDuration proto.InternalMessageInfo

type TypeList struct {
	Element *Type `protobuf:"bytes,1,opt,name=element,proto3" json:"element,omitempty"`
}

func (m *TypeList) Reset()         { *m = TypeList{} }
func (m *TypeList) String() string { return proto.CompactTextString(m) }
func (*TypeList) ProtoMessage()    {}
func (*TypeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{26}
}
func (m *TypeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeList.Merge(m, src)
}
func (m *TypeList) XXX_Size() int {
	return m.Size()
}
func (m *TypeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeList.DiscardUnknown(m)
}

var xxx_messageInfo_TypeList proto.InternalMessageInfo

func (m *TypeList) GetElement() *Type {
	if m != nil {
		return m.Element
	}
	return nil
}

type TypeStruct struct {
	Fields []*TypeStructField `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
}

func (m *TypeStruct) Reset()         { *m = TypeStruct{} }
func (m *TypeStruct) String() string { return proto.CompactTextString(m) }
func (*TypeStruct) ProtoMessage()    {}
func (*TypeStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{27}
}
func (m *TypeStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeStruct.Merge(m, src)
}
func (m *TypeStruct) XXX_Size() int {
	return m.Size()
}
func (m *TypeStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeStruct.DiscardUnknown(m)
}

var xxx_messageInfo_TypeStruct proto.InternalMessageInfo

func (m *TypeStruct) GetFields() []*TypeStructField {
	if m != nil {
		return m.Fields
	}
	return nil
}

type TypeStructField struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type *Type  `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *TypeStructField) Reset()         { *m = TypeStructField{} }
func (m *TypeStructField) String() string { return proto.CompactTextString(m) }
func (*TypeStructField) ProtoMessage()    {}
func (*TypeStructField) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{28}
}
func (m *TypeStructField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeStructField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeStructField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeStructField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeStructField.Merge(m, src)
}
func (m *TypeStructField) XXX_Size() int {
	return m.Size()
}
func (m *TypeStructField) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeStructField.DiscardUnknown(m)
}

var xxx_messageInfo_TypeStructField proto.InternalMessageInfo

func (m *TypeStructField) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TypeStructField) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

type TypeUnion struct {
	Alternatives []*Type `protobuf:"bytes,1,rep,name=alternatives,proto3" json:"alternatives,omitempty"`
}

func (m *TypeUnion) Reset()         { *m = TypeUnion{} }
func (m *TypeUnion) String() string { return proto.CompactTextString(m) }
func (*TypeUnion) ProtoMessage()    {}
func (*TypeUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{29}
}
func (m *TypeUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeUnion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeUnion.Merge(m, src)
}
func (m *TypeUnion) XXX_Size() int {
	return m.Size()
}
func (m *TypeUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeUnion.DiscardUnknown(m)
}

var xxx_messageInfo_TypeUnion proto.InternalMessageInfo

func (m *TypeUnion) GetAlternatives() []*Type {
	if m != nil {
		return m.Alternatives
	}
	return nil
}

type TypeAny struct {
}

func (m *TypeAny) Reset()         { *m = TypeAny{} }
func (m *TypeAny) String() string { return proto.CompactTextString(m) }
func (*TypeAny) ProtoMessage()    {}
func (*TypeAny) Descriptor() ([]byte, []int) {
	return fileDescriptor_a41a6b6d08976c8c, []int{30}
}
func (m *TypeAny) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeAny) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeAny.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeAny) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeAny.Merge(m, src)
}
func (m *TypeAny) XXX_Size() int {
	return m.Size()
}
func (m *TypeAny) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeAny.DiscardUnknown(m)
}

var xxx_messageInfo_TypeAny proto.InternalMessageInfo

func init() {
	proto.RegisterType((*GetPluginMetadataRequest)(nil), "plugins.GetPluginMetadataRequest")
	proto.RegisterType((*GetPluginMetadataResponse)(nil), "plugins.GetPluginMetadataResponse")
	proto.RegisterType((*GetSchemaRequest)(nil), "plugins.GetSchemaRequest")
	proto.RegisterType((*Schema)(nil), "plugins.Schema")
	proto.RegisterType((*SchemaField)(nil), "plugins.SchemaField")
	proto.RegisterType((*RunRequest)(nil), "plugins.RunRequest")
	proto.RegisterMapType((map[string]*Value)(nil), "plugins.RunRequest.VariableValuesEntry")
	proto.RegisterType((*Expression)(nil), "plugins.Expression")
	proto.RegisterType((*Variable)(nil), "plugins.Variable")
	proto.RegisterType((*Constant)(nil), "plugins.Constant")
	proto.RegisterType((*FunctionCall)(nil), "plugins.FunctionCall")
	proto.RegisterType((*And)(nil), "plugins.And")
	proto.RegisterType((*Or)(nil), "plugins.Or")
	proto.RegisterType((*TypeAssertion)(nil), "plugins.TypeAssertion")
	proto.RegisterType((*Value)(nil), "plugins.Value")
	proto.RegisterType((*Values)(nil), "plugins.Values")
	proto.RegisterType((*RunMessage)(nil), "plugins.RunMessage")
	proto.RegisterType((*MetadataMessage)(nil), "plugins.MetadataMessage")
	proto.RegisterType((*Record)(nil), "plugins.Record")
	proto.RegisterType((*Type)(nil), "plugins.Type")
	proto.RegisterType((*TypeNull)(nil), "plugins.TypeNull")
	proto.RegisterType((*TypeInt)(nil), "plugins.TypeInt")
	proto.RegisterType((*TypeFloat)(nil), "plugins.TypeFloat")
	proto.RegisterType((*TypeBoolean)(nil), "plugins.TypeBoolean")
	proto.RegisterType((*TypeStr)(nil), "plugins.TypeStr")
	proto.RegisterType((*TypeTime)(nil), "plugins.TypeTime")
	proto.RegisterType((*TypeDuration)(nil), "plugins.TypeDuration")
	proto.RegisterType((*TypeList)(nil), "plugins.TypeList")
	proto.RegisterType((*TypeStruct)(nil), "plugins.TypeStruct")
	proto.RegisterType((*TypeStructField)(nil), "plugins.TypeStructField")
	proto.RegisterType((*TypeUnion)(nil), "plugins.TypeUnion")
	proto.RegisterType((*TypeAny)(nil), "plugins.TypeAny")
}

func init() { proto.RegisterFile("plugins.proto", fileDescriptor_a41a6b6d08976c8c) }

var fileDescriptor_a41a6b6d08976c8c = []byte{
	// 1312 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4b, 0x6f, 0xdb, 0x46,
	0x10, 0x16, 0x45, 0x59, 0x8f, 0x91, 0xfc, 0xc8, 0xda, 0x0d, 0x18, 0xa1, 0x51, 0x9d, 0x6d, 0x52,
	0xbb, 0x45, 0x2b, 0xc9, 0x72, 0x81, 0x04, 0x41, 0x9a, 0xc2, 0xca, 0x4b, 0x05, 0x92, 0x26, 0x65,
	0x1e, 0x87, 0x5c, 0x84, 0x95, 0xb4, 0x56, 0x88, 0x50, 0x4b, 0x85, 0x5c, 0xba, 0xd5, 0x4f, 0x68,
	0x4f, 0xfd, 0x59, 0x3d, 0xe6, 0xd8, 0x5b, 0x8b, 0xe4, 0xd4, 0x43, 0xff, 0x40, 0x4f, 0xc5, 0xbe,
	0x28, 0x52, 0xa6, 0x8d, 0x20, 0x37, 0x72, 0xe6, 0x9b, 0xd9, 0xd9, 0x6f, 0xbf, 0x99, 0x5d, 0x58,
	0x9f, 0xfb, 0xf1, 0xd4, 0x63, 0x51, 0x7b, 0x1e, 0x06, 0x3c, 0x40, 0x15, 0xfd, 0xdb, 0xfc, 0x6c,
	0x1a, 0x04, 0x53, 0x9f, 0x76, 0xa4, 0x79, 0x14, 0x1f, 0x77, 0xb8, 0x37, 0xa3, 0x11, 0x27, 0xb3,
	0xb9, 0x42, 0x36, 0x5b, 0xab, 0x80, 0x49, 0x1c, 0x12, 0xee, 0x05, 0x4c, 0xf9, 0x71, 0x13, 0x9c,
	0x07, 0x94, 0x3f, 0x91, 0xe9, 0x1e, 0x51, 0x4e, 0x26, 0x84, 0x13, 0x97, 0xbe, 0x89, 0x69, 0xc4,
	0xf1, 0x6f, 0x16, 0x5c, 0xca, 0x71, 0x46, 0xf3, 0x80, 0x45, 0x14, 0x75, 0x60, 0x3b, 0x8a, 0xe7,
	0xf3, 0x20, 0xe4, 0x74, 0x32, 0x3c, 0x8e, 0xd9, 0x58, 0x64, 0x8d, 0x1c, 0x6b, 0xd7, 0xde, 0xaf,
	0xb9, 0x28, 0x71, 0xdd, 0x37, 0x1e, 0x74, 0x0b, 0x9a, 0xcb, 0x00, 0xfa, 0xcb, 0x3c, 0xa4, 0x51,
	0xe4, 0x05, 0x6c, 0xc8, 0x17, 0x73, 0x1a, 0x39, 0xc5, 0x5d, 0x7b, 0xdf, 0x76, 0x9d, 0x04, 0x71,
	0x2f, 0x01, 0x3c, 0x13, 0x7e, 0xbc, 0x0f, 0x5b, 0x0f, 0x28, 0x7f, 0x3a, 0x7e, 0x45, 0x67, 0xa6,
	0x40, 0xb4, 0x03, 0x6b, 0x9c, 0x8c, 0x7c, 0xea, 0x58, 0xbb, 0xd6, 0x7e, 0xcd, 0x55, 0x3f, 0xf8,
	0x39, 0x94, 0x15, 0x0c, 0x7d, 0x0d, 0xe5, 0x63, 0x8f, 0xfa, 0x13, 0x55, 0x55, 0xbd, 0xb7, 0xd3,
	0x36, 0x34, 0x2a, 0xc0, 0x7d, 0xe1, 0x74, 0x35, 0x06, 0x5d, 0x06, 0x10, 0xec, 0x0d, 0xe5, 0xaf,
	0x53, 0xdc, 0xb5, 0xf6, 0x6d, 0xb7, 0x26, 0x2c, 0x12, 0x86, 0xef, 0x42, 0x3d, 0x15, 0x85, 0x10,
	0x94, 0x18, 0x99, 0x99, 0xa5, 0xe5, 0x37, 0xba, 0x02, 0x25, 0xb1, 0x19, 0x19, 0x5b, 0xef, 0xad,
	0x27, 0xab, 0x89, 0x1d, 0xb8, 0xd2, 0x85, 0xff, 0xb3, 0x00, 0xdc, 0x98, 0x9d, 0xbb, 0x03, 0x74,
	0x00, 0xb5, 0x79, 0x48, 0x27, 0xde, 0x98, 0x70, 0x93, 0x6c, 0x3b, 0x49, 0xb6, 0x24, 0xc6, 0x5d,
	0xa2, 0xd0, 0x13, 0xd8, 0x3c, 0x21, 0xa1, 0x27, 0xc2, 0x87, 0x27, 0xc4, 0x8f, 0x69, 0xe4, 0xd8,
	0x72, 0xcf, 0x7b, 0x49, 0xe0, 0x72, 0xd9, 0xf6, 0x0b, 0x0d, 0x7d, 0x21, 0x91, 0xf7, 0x18, 0x0f,
	0x17, 0xee, 0xc6, 0x49, 0xc6, 0xd8, 0xfc, 0x09, 0xb6, 0x73, 0x60, 0x68, 0x0b, 0xec, 0xd7, 0x74,
	0xa1, 0xeb, 0x15, 0x9f, 0xe8, 0x2a, 0xac, 0xc9, 0x15, 0x75, 0xa5, 0x1b, 0xc9, 0x82, 0x32, 0xcc,
	0x55, 0xce, 0x9b, 0xc5, 0x1b, 0x16, 0xfe, 0xab, 0x08, 0xb0, 0x2c, 0x3f, 0xa1, 0xcb, 0x3a, 0x93,
	0x2e, 0xd4, 0x81, 0xaa, 0x29, 0x4b, 0xa7, 0xbf, 0x90, 0x4a, 0xaf, 0x1c, 0x83, 0x82, 0x9b, 0x80,
	0x44, 0xc0, 0x38, 0x60, 0x11, 0x27, 0x8c, 0x3b, 0xf6, 0x4a, 0xc0, 0x1d, 0xed, 0x10, 0x01, 0x06,
	0x84, 0x6e, 0xc1, 0xba, 0x11, 0xef, 0x70, 0x4c, 0x7c, 0xdf, 0x29, 0xc9, 0xa8, 0x4f, 0x92, 0x28,
	0x23, 0xe0, 0x3b, 0xc4, 0xf7, 0x07, 0x05, 0xb7, 0x71, 0x9c, 0xfa, 0x47, 0xbb, 0x60, 0x13, 0x36,
	0x71, 0xd6, 0x64, 0x4c, 0x23, 0x89, 0x39, 0x62, 0x93, 0x41, 0xc1, 0x15, 0x2e, 0x74, 0x19, 0x8a,
	0x41, 0xe8, 0x94, 0x25, 0xa0, 0x9e, 0x00, 0x1e, 0x87, 0x83, 0x82, 0x5b, 0x0c, 0x42, 0xf4, 0x3d,
	0x6c, 0x88, 0x8d, 0x0e, 0x49, 0x14, 0xd1, 0x50, 0xa4, 0x75, 0x2a, 0x12, 0x7a, 0x31, 0xc3, 0xc6,
	0x91, 0xf1, 0x0e, 0x0a, 0xee, 0x3a, 0x4f, 0x1b, 0xfa, 0x0d, 0x80, 0x65, 0x2f, 0xe1, 0x5b, 0x50,
	0x35, 0xb4, 0xe4, 0x2a, 0xf4, 0x53, 0x00, 0x2f, 0x1a, 0xfa, 0xf4, 0x84, 0xfa, 0xc3, 0xae, 0x64,
	0xb4, 0xea, 0x56, 0xbd, 0xe8, 0xa1, 0x30, 0x74, 0x71, 0x17, 0xaa, 0x86, 0xa3, 0xe5, 0xa9, 0x5a,
	0xe7, 0x9c, 0x2a, 0x7e, 0x0e, 0x8d, 0x34, 0x3f, 0xb9, 0x6b, 0x1e, 0x40, 0x8d, 0x84, 0xd3, 0x78,
	0x46, 0x19, 0x57, 0x6d, 0x7e, 0x96, 0x9a, 0x13, 0x14, 0xbe, 0x01, 0xf6, 0x11, 0x9b, 0x64, 0x23,
	0xad, 0x0f, 0x8a, 0xbc, 0x0e, 0xc5, 0xc7, 0xe1, 0xc7, 0x2c, 0xc9, 0x61, 0x3d, 0xc3, 0x34, 0x3a,
	0x4c, 0x13, 0xab, 0x59, 0xc8, 0x4d, 0x92, 0x82, 0xa1, 0x36, 0xd4, 0x39, 0x09, 0xa7, 0x94, 0x0f,
	0xcf, 0x1e, 0x04, 0xa0, 0x10, 0xe2, 0x1b, 0xff, 0x5b, 0x84, 0x35, 0x49, 0xe8, 0x87, 0x34, 0xc3,
	0x0e, 0x94, 0x58, 0xec, 0xfb, 0xea, 0xd8, 0x06, 0x05, 0x57, 0xfe, 0x21, 0x04, 0xb6, 0xa7, 0xc5,
	0x6e, 0x0b, 0xd1, 0x79, 0x8c, 0xa3, 0x8b, 0xb0, 0x76, 0xec, 0x07, 0x84, 0x4b, 0x31, 0x5b, 0x83,
	0x82, 0xab, 0x7e, 0x51, 0x13, 0x2a, 0xa3, 0x20, 0xf0, 0x29, 0x61, 0x52, 0xb2, 0x22, 0x89, 0x31,
	0x88, 0x3c, 0x11, 0x57, 0x4a, 0xad, 0x89, 0x3c, 0x11, 0x0f, 0x51, 0x17, 0x4a, 0x62, 0x00, 0x6a,
	0x4d, 0x36, 0xdb, 0xea, 0x32, 0x69, 0x9b, 0xcb, 0xa4, 0xfd, 0xcc, 0xdc, 0x36, 0xa2, 0x1a, 0x81,
	0x44, 0xd7, 0xa1, 0x6a, 0x6e, 0x18, 0xa7, 0x2a, 0xa3, 0x2e, 0x9d, 0x8a, 0xba, 0xab, 0x01, 0xa2,
	0x0f, 0x0d, 0x18, 0x5d, 0x83, 0x92, 0xef, 0x45, 0xdc, 0xa9, 0xc9, 0xa0, 0xcd, 0xac, 0xdc, 0x22,
	0x91, 0x5f, 0xb8, 0xd1, 0xb7, 0xd0, 0x90, 0xf3, 0xd9, 0x0c, 0x39, 0x38, 0x0b, 0x5e, 0x97, 0x30,
	0xf5, 0xdb, 0xaf, 0x68, 0x31, 0xe3, 0x2e, 0x94, 0x95, 0x09, 0x7d, 0x01, 0x65, 0x9d, 0x42, 0x09,
	0x6b, 0x55, 0xe0, 0xda, 0x8b, 0x7f, 0x55, 0x03, 0xfb, 0x11, 0x8d, 0x22, 0x32, 0xa5, 0xe8, 0x1e,
	0x6c, 0xcd, 0xf4, 0x4d, 0x38, 0x9c, 0x29, 0x9b, 0x3e, 0x32, 0x27, 0x49, 0x60, 0xae, 0x4a, 0x1d,
	0x33, 0x28, 0xb8, 0x9b, 0xb3, 0xac, 0x09, 0x7d, 0x09, 0xe5, 0x90, 0x8e, 0x83, 0x70, 0xa2, 0x25,
	0xb2, 0xdc, 0x80, 0x2b, 0xcd, 0x83, 0x82, 0xab, 0x01, 0xfd, 0x1a, 0x54, 0xc6, 0x01, 0xe3, 0x94,
	0x71, 0x4c, 0x60, 0x73, 0x25, 0x37, 0xba, 0x09, 0xb5, 0x9f, 0x09, 0xa7, 0xe1, 0x8c, 0x84, 0xaf,
	0x75, 0x21, 0xe7, 0x1f, 0xd3, 0x12, 0xde, 0x47, 0xa7, 0xf7, 0x82, 0x1f, 0x43, 0x59, 0x55, 0x80,
	0xae, 0x65, 0x07, 0xc0, 0x2a, 0xc5, 0x7a, 0x02, 0xa0, 0x16, 0x40, 0x48, 0x79, 0x48, 0xe4, 0x0c,
	0xd0, 0x13, 0x25, 0x65, 0xc1, 0xff, 0xd8, 0x50, 0x12, 0x1a, 0x46, 0x7b, 0x5a, 0xbd, 0xd6, 0xca,
	0x54, 0x16, 0xce, 0x1f, 0x63, 0x39, 0x5b, 0x95, 0xa0, 0xaf, 0x2a, 0x41, 0x2b, 0x62, 0xb6, 0x32,
	0xb8, 0x1f, 0xe4, 0xf0, 0x96, 0x12, 0xff, 0xca, 0x48, 0x5c, 0x4d, 0x79, 0x94, 0xc1, 0xdd, 0x17,
	0x9e, 0xa5, 0xec, 0xbb, 0x4b, 0xd9, 0xab, 0xe9, 0xbe, 0x93, 0x41, 0xf7, 0x95, 0x2f, 0xdd, 0x0c,
	0x57, 0x55, 0x33, 0xac, 0xe5, 0xd4, 0xf0, 0x94, 0x87, 0xa6, 0x3d, 0xf6, 0x74, 0x7b, 0x94, 0x73,
	0xb6, 0x24, 0x38, 0x4f, 0xba, 0xe2, 0x30, 0xd5, 0x15, 0x95, 0x95, 0xfb, 0x45, 0x80, 0x73, 0x3b,
	0x62, 0x4f, 0x77, 0x44, 0x35, 0x27, 0xfb, 0x43, 0x2f, 0xe2, 0x49, 0x4f, 0x7c, 0x03, 0xe5, 0x88,
	0x87, 0xf1, 0xd8, 0x34, 0xcf, 0xf6, 0x6a, 0xbd, 0xf1, 0x58, 0x80, 0x35, 0x48, 0x30, 0x17, 0x33,
	0x51, 0x09, 0xe4, 0x30, 0xf7, 0x9c, 0xa9, 0x32, 0x14, 0x44, 0xf0, 0x40, 0xd8, 0xc2, 0xa9, 0xe7,
	0xf0, 0x70, 0xc4, 0x16, 0xea, 0x8e, 0x5b, 0xf4, 0xcb, 0x6a, 0x76, 0x61, 0x80, 0xaa, 0x39, 0x4d,
	0x5c, 0x83, 0x8a, 0x3e, 0x31, 0x5c, 0x87, 0x5a, 0x72, 0x28, 0x78, 0x1d, 0xea, 0x29, 0xce, 0x0d,
	0xec, 0x29, 0x0f, 0x4d, 0xb4, 0x20, 0x0e, 0x6f, 0x40, 0x23, 0xcd, 0x0b, 0x3e, 0x54, 0x3e, 0xb1,
	0x6d, 0xb4, 0x07, 0x15, 0xea, 0x53, 0x31, 0xb5, 0xf3, 0x87, 0xa5, 0xf1, 0xe2, 0xdb, 0x00, 0x4b,
	0x02, 0x50, 0x77, 0xe5, 0x31, 0xe8, 0xe4, 0xb0, 0x94, 0x79, 0x10, 0xe2, 0x01, 0x6c, 0xae, 0xb8,
	0x3e, 0xf6, 0xd5, 0x77, 0x5b, 0x31, 0x20, 0xc9, 0x45, 0x07, 0xd0, 0x20, 0x3e, 0xa7, 0x21, 0x23,
	0xdc, 0x3b, 0x49, 0xe6, 0xcf, 0x4a, 0x5c, 0x06, 0x62, 0x58, 0x3a, 0x62, 0x8b, 0xde, 0x5b, 0x0b,
	0xca, 0xea, 0x45, 0x8e, 0x5e, 0xc2, 0x85, 0x53, 0xcf, 0x73, 0x74, 0x25, 0xc9, 0x73, 0xd6, 0xbb,
	0xbe, 0x89, 0xcf, 0x83, 0xe8, 0xd7, 0xfd, 0x75, 0xa8, 0x25, 0xcf, 0x6d, 0x74, 0x29, 0x1d, 0x90,
	0x79, 0x82, 0x37, 0x37, 0x57, 0x9e, 0xd4, 0xe8, 0x00, 0x6c, 0x37, 0x66, 0x68, 0x3b, 0xe7, 0xd9,
	0xd9, 0xcc, 0x18, 0xf5, 0x04, 0xeb, 0x5a, 0xfd, 0xef, 0xfe, 0x78, 0xd7, 0xb2, 0xde, 0xbe, 0x6b,
	0x59, 0x7f, 0xbf, 0x6b, 0x59, 0xbf, 0xbf, 0x6f, 0x15, 0xde, 0xbe, 0x6f, 0x15, 0xfe, 0x7c, 0xdf,
	0x2a, 0xbc, 0xfc, 0x7c, 0xea, 0xf1, 0x57, 0xf1, 0xa8, 0x3d, 0x0e, 0x66, 0x9d, 0x71, 0x3c, 0xa2,
	0xbd, 0x5e, 0xaf, 0xd7, 0x09, 0xc6, 0x3c, 0x88, 0xde, 0xf8, 0x1d, 0x9d, 0x6b, 0x54, 0x96, 0x73,
	0xee, 0xf0, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8d, 0x9b, 0x8f, 0xbb, 0x24, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PluginClient is the client API for Plugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PluginClient interface {
	GetPluginMetadata(ctx context.Context, in *GetPluginMetadataRequest, opts ...grpc.CallOption) (*GetPluginMetadataResponse, error)
	GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*Schema, error)
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (Plugin_RunClient, error)
}

type pluginClient struct {
	cc *grpc.ClientConn
}

func NewPluginClient(cc *grpc.ClientConn) PluginClient {
	return &pluginClient{cc}
}

func (c *pluginClient) GetPluginMetadata(ctx context.Context, in *GetPluginMetadataRequest, opts ...grpc.CallOption) (*GetPluginMetadataResponse, error) {
	out := new(GetPluginMetadataResponse)
	err := c.cc.Invoke(ctx, "/plugins.Plugin/GetPluginMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*Schema, error) {
	out := new(Schema)
	err := c.cc.Invoke(ctx, "/plugins.Plugin/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (Plugin_RunClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Plugin_serviceDesc.Streams[0], "/plugins.Plugin/Run", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_RunClient interface {
	Recv() (*RunMessage, error)
	grpc.ClientStream
}

type pluginRunClient struct {
	grpc.ClientStream
}

func (x *pluginRunClient) Recv() (*RunMessage, error) {
	m := new(RunMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PluginServer is the server API for Plugin service.
type PluginServer interface {
	GetPluginMetadata(context.Context, *GetPluginMetadataRequest) (*GetPluginMetadataResponse, error)
	GetSchema(context.Context, *GetSchemaRequest) (*Schema, error)
	Run(*RunRequest, Plugin_RunServer) error
}

// UnimplementedPluginServer can be embedded to have forward compatible implementations.
type UnimplementedPluginServer struct {
}

func (*UnimplementedPluginServer) GetPluginMetadata(ctx context.Context, req *GetPluginMetadataRequest) (*GetPluginMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginMetadata not implemented")
}
func (*UnimplementedPluginServer) GetSchema(ctx context.Context, req *GetSchemaRequest) (*Schema, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchema not implemented")
}
func (*UnimplementedPluginServer) Run(req *RunRequest, srv Plugin_RunServer) error {
	return status.Errorf(codes.Unimplemented, "method Run not implemented")
}

func RegisterPluginServer(s *grpc.Server, srv PluginServer) {
	s.RegisterService(&_Plugin_serviceDesc, srv)
}

func _Plugin_GetPluginMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPluginMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).GetPluginMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Plugin/GetPluginMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).GetPluginMetadata(ctx, req.(*GetPluginMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Plugin/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).GetSchema(ctx, req.(*GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Run_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).Run(m, &pluginRunServer{stream})
}

type Plugin_RunServer interface {
	Send(*RunMessage) error
	grpc.ServerStream
}

type pluginRunServer struct {
	grpc.ServerStream
}

func (x *pluginRunServer) Send(m *RunMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _Plugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Plugin",
	HandlerType: (*PluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPluginMetadata",
			Handler:    _Plugin_GetPluginMetadata_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _Plugin_GetSchema_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run",
			Handler:       _Plugin_Run_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

func (m *GetPluginMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPluginMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPluginMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetPluginMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPluginMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPluginMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupportedExpressionTypes) > 0 {
		dAtA2 := make([]byte, len(m.SupportedExpressionTypes)*10)
		var j1 int
		for _, num1 := range m.SupportedExpressionTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPlugins(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SupportedFunctions) > 0 {
		for iNdEx := len(m.SupportedFunctions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SupportedFunctions[iNdEx])
			copy(dAtA[i:], m.SupportedFunctions[iNdEx])
			i = encodeVarintPlugins(dAtA, i, uint64(len(m.SupportedFunctions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlugins(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeField != 0 {
		i = encodeVarintPlugins(dAtA, i, uint64(m.TimeField))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchemaField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlugins(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VariableValues) > 0 {
		for k := range m.VariableValues {
			v := m.VariableValues[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlugins(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlugins(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlugins(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Predicate != nil {
		{
			size, err := m.Predicate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlugins(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expression != nil {
		{
			size := m.Expression.Size()
			i -= size
			if _, err := m.Expression.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expression_Variable) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_Variable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Variable != nil {
		{
			size, err := m.Variable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Expression_Constant) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Constant != nil {
		{
			size, err := m.Constant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Expression_FunctionCall) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_FunctionCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionCall != nil {
		{
			size, err := m.FunctionCall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Expression_And) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_And) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.And != nil {
		{
			size, err := m.And.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Expression_Or) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_Or) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Or != nil {
		{
			size, err := m.Or.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Expression_TypeAssertion) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_TypeAssertion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TypeAssertion != nil {
		{
			size, err := m.TypeAssertion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Variable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Variable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Variable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLevel_0 {
		i--
		if m.IsLevel_0 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlugins(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Constant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Constant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FunctionCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		for iNdEx := len(m.Arguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Arguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlugins(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *And) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *And) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *And) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		for iNdEx := len(m.Arguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Arguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Or) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Or) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Or) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		for iNdEx := len(m.Arguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Arguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *TypeAssertion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeAssertion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeAssertion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetType != nil {
		{
			size, err := m.TargetType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Expression != nil {
		{
			size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value_Null) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Null) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Null {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Value_Int) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlugins(dAtA, i, uint64(m.Int))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Value_Float) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Float) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float))))
	i--
	dAtA[i] = 0x21
	return len(dAtA) - i, nil
}
func (m *Value_Boolean) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Boolean) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Boolean {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Value_Str) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Str) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Str)
	copy(dAtA[i:], m.Str)
	i = encodeVarintPlugins(dAtA, i, uint64(len(m.Str)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *Value_Time) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Time) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Value_Duration) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_Duration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Duration != nil {
		{
			size, err := m.Duration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Value_List) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.List != nil {
		{
			size, err := m.List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Value_FieldValues) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Value_FieldValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FieldValues != nil {
		{
			size, err := m.FieldValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Values) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Values) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Values) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RunMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RunMessage_MetadataMessage) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RunMessage_MetadataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MetadataMessage != nil {
		{
			size, err := m.MetadataMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RunMessage_Record) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RunMessage_Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Record != nil {
		{
			size, err := m.Record.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MetadataMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetadataMessage != nil {
		{
			size := m.MetadataMessage.Size()
			i -= size
			if _, err := m.MetadataMessage.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetadataMessage_Watermark) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MetadataMessage_Watermark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Watermark != nil {
		{
			size, err := m.Watermark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retraction {
		i--
		if m.Retraction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Type_Null) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Null) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Null != nil {
		{
			size, err := m.Null.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Type_Int) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int != nil {
		{
			size, err := m.Int.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Type_Float) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Float) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Float != nil {
		{
			size, err := m.Float.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Type_Boolean) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Boolean) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Boolean != nil {
		{
			size, err := m.Boolean.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Type_Str) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Str) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Str != nil {
		{
			size, err := m.Str.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Type_Time) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Time) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Type_Duration) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Duration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Duration != nil {
		{
			size, err := m.Duration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Type_List) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.List != nil {
		{
			size, err := m.List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Type_Struct) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Struct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Struct != nil {
		{
			size, err := m.Struct.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Type_Union) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Union) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Union != nil {
		{
			size, err := m.Union.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Type_Any) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Type_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *TypeNull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeInt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeInt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeInt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeFloat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeFloat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeFloat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeBoolean) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeBoolean) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeBoolean) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeStr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeStr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeStr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeDuration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeDuration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeDuration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TypeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Element != nil {
		{
			size, err := m.Element.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TypeStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TypeStructField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeStructField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeStructField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlugins(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlugins(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TypeUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Alternatives) > 0 {
		for iNdEx := len(m.Alternatives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Alternatives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlugins(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TypeAny) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeAny) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeAny) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPlugins(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlugins(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetPluginMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetPluginMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupportedFunctions) > 0 {
		for _, s := range m.SupportedFunctions {
			l = len(s)
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	if len(m.SupportedExpressionTypes) > 0 {
		l = 0
		for _, e := range m.SupportedExpressionTypes {
			l += sovPlugins(uint64(e))
		}
		n += 1 + sovPlugins(uint64(l)) + l
	}
	return n
}

func (m *GetSchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	if m.TimeField != 0 {
		n += 1 + sovPlugins(uint64(m.TimeField))
	}
	return n
}

func (m *SchemaField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}

func (m *RunRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.Predicate != nil {
		l = m.Predicate.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	if len(m.VariableValues) > 0 {
		for k, v := range m.VariableValues {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPlugins(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPlugins(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPlugins(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.Expression != nil {
		n += m.Expression.Size()
	}
	return n
}

func (m *Expression_Variable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Variable != nil {
		l = m.Variable.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Expression_Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != nil {
		l = m.Constant.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Expression_FunctionCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionCall != nil {
		l = m.FunctionCall.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Expression_And) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Expression_Or) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Expression_TypeAssertion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeAssertion != nil {
		l = m.TypeAssertion.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Variable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.IsLevel_0 {
		n += 2
	}
	return n
}

func (m *Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}

func (m *FunctionCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlugins(uint64(l))
	}
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	return n
}

func (m *And) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	return n
}

func (m *Or) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	return n
}

func (m *TypeAssertion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expression != nil {
		l = m.Expression.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.TargetType != nil {
		l = m.TargetType.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Value_Null) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_Int) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlugins(uint64(m.Int))
	return n
}
func (m *Value_Float) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_Boolean) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_Str) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Str)
	n += 1 + l + sovPlugins(uint64(l))
	return n
}
func (m *Value_Time) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Value_Duration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Value_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Value_FieldValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldValues != nil {
		l = m.FieldValues.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Values) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	return n
}

func (m *RunMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *RunMessage_MetadataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetadataMessage != nil {
		l = m.MetadataMessage.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *RunMessage_Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Record != nil {
		l = m.Record.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *MetadataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetadataMessage != nil {
		n += m.MetadataMessage.Size()
	}
	return n
}

func (m *MetadataMessage_Watermark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watermark != nil {
		l = m.Watermark.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.Retraction {
		n += 2
	}
	return n
}

func (m *Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Type_Null) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Null != nil {
		l = m.Null.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Int) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int != nil {
		l = m.Int.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Float) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Float != nil {
		l = m.Float.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Boolean) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Boolean != nil {
		l = m.Boolean.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Str) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Str != nil {
		l = m.Str.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Time) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Duration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Struct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Struct != nil {
		l = m.Struct.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Union) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		l = m.Union.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *Type_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}
func (m *TypeNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeInt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeFloat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeBoolean) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeStr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeDuration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TypeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Element != nil {
		l = m.Element.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}

func (m *TypeStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	return n
}

func (m *TypeStructField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlugins(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovPlugins(uint64(l))
	}
	return n
}

func (m *TypeUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Alternatives) > 0 {
		for _, e := range m.Alternatives {
			l = e.Size()
			n += 1 + l + sovPlugins(uint64(l))
		}
	}
	return n
}

func (m *TypeAny) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPlugins(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlugins(x uint64) (n int) {
	return sovPlugins(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetPluginMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPluginMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPluginMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPluginMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPluginMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPluginMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedFunctions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedFunctions = append(m.SupportedFunctions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlugins
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedExpressionTypes = append(m.SupportedExpressionTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlugins
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlugins
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlugins
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SupportedExpressionTypes) == 0 {
					m.SupportedExpressionTypes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlugins
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedExpressionTypes = append(m.SupportedExpressionTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedExpressionTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &SchemaField{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeField", wireType)
			}
			m.TimeField = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeField |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predicate == nil {
				m.Predicate = &Expression{}
			}
			if err := m.Predicate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariableValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VariableValues == nil {
				m.VariableValues = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlugins
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlugins
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlugins
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlugins
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlugins
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlugins
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlugins
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlugins(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPlugins
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VariableValues[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Variable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expression = &Expression_Variable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Constant{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expression = &Expression_Constant{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionCall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionCall{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expression = &Expression_FunctionCall{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &And{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expression = &Expression_And{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Or{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expression = &Expression_Or{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeAssertion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeAssertion{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expression = &Expression_TypeAssertion{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLevel_0", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLevel_0 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Constant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Constant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Constant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, &Expression{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *And) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: And: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: And: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, &Expression{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Or) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Or: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Or: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, &Expression{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeAssertion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeAssertion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeAssertion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expression == nil {
				m.Expression = &Expression{}
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetType == nil {
				m.TargetType = &Type{}
			}
			if err := m.TargetType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Null", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Value_Null{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int{v}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Value_Float{float64(math.Float64frombits(v))}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boolean", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Value_Boolean{b}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Value_Str{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_Time{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Duration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_Duration{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Values{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_List{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Values{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_FieldValues{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Values) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Values: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Values: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Value{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetadataMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RunMessage_MetadataMessage{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Record{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RunMessage_Record{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watermark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MetadataMessage = &MetadataMessage_Watermark{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Values{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retraction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retraction = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Null", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeNull{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Null{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeInt{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Int{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeFloat{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Float{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boolean", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeBoolean{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Boolean{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeStr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Str{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeTime{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Time{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeDuration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Duration{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_List{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Struct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeStruct{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Struct{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeUnion{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Union{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeAny{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Type_Any{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeNull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeNull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeNull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeInt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeFloat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeFloat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeFloat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeBoolean) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeBoolean: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeBoolean: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeStr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeDuration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeDuration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeDuration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Element", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Element == nil {
				m.Element = &Type{}
			}
			if err := m.Element.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &TypeStructField{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeStructField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeStructField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeStructField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alternatives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlugins
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlugins
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alternatives = append(m.Alternatives, &Type{})
			if err := m.Alternatives[len(m.Alternatives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeAny) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeAny: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeAny: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlugins(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlugins
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlugins(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlugins
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlugins
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlugins
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPlugins
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPlugins
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPlugins(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPlugins
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPlugins = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlugins   = fmt.Errorf("proto: integer overflow")
)
